#!/usr/bin/env python
import argparse
from operator import itemgetter
from contextlib import closing
from itertools import chain
from io import StringIO
from functools import reduce

import psycopg2

from tabulate import tabulate


fst = itemgetter(0)


def unlines(lines):
    return "\n".join(lines)


def to_lines(text):
    return (line.rstrip('\n') for line in StringIO(text))


def format_value(value):
    if value is None:
        return ''
    else:
        return value


def ljoin(sep, items):
    return reduce(lambda x, y: x + [sep] + y, items, [])


class Schema(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.tables = []
        self.views = []
        self.functions = []

    @staticmethod
    def all_names(conn):
        query = (
            'SELECT nspname '
            'FROM pg_namespace'
        )

        with closing(conn.cursor()) as cursor:
            cursor.execute(query)

            return [name for name, in cursor.fetchall()]

    @staticmethod
    def load_description(conn, name):
        query = (
            'SELECT d.description '
            'FROM pg_namespace n '
            'LEFT JOIN pg_description d ON d.objoid = n.oid '
            'WHERE n.nspname = %s'
        )

        args = (name, )

        with closing(conn.cursor()) as cursor:
            cursor.execute(query, args)

            if cursor.rowcount < 1:
                raise Exception('no schema named {}'.format(name))

            description, = cursor.fetchone()

        return description

    @staticmethod
    def load(conn, name):
        schema = Schema(name, Schema.load_description(conn, name))

        schema.tables = Table.load_all(conn, name)
        schema.functions = Function.load_all(conn, name)

        return schema


class Column(object):
    def __init__(self, name, type, description):
        self.name = name
        self.type = type
        self.description = description

    @staticmethod
    def load_all(conn, table_oid):
        query = (
            'SELECT attname, format_type(atttypid, atttypmod), d.description '
            'FROM pg_class c '
            'JOIN pg_attribute a ON c.oid = a.attrelid '
            'LEFT JOIN pg_description d ON d.objoid = c.oid AND d.objsubid = a.attnum '
            'WHERE attnum > 0 AND c.oid = %s'
        )

        args = (table_oid,)

        with closing(conn.cursor()) as cursor:
            cursor.execute(query, args)

            return [Column(name, type, description) for name, type, description in cursor.fetchall()]


class Table(object):
    def __init__(self, name, columns, description):
        self.name = name
        self.columns = columns
        self.description = description

    @staticmethod
    def load(conn, oid):
        query = (
            "SELECT c.relname, d.description "
            "FROM pg_class c "
            "LEFT JOIN pg_description d ON d.objoid = c.oid AND d.objsubid = 0 "
            "WHERE c.oid = %s"
        )

        args = (oid,)

        with closing(conn.cursor()) as cursor:
            cursor.execute(query, args)

            (table_name, description) = cursor.fetchone()

        columns = Column.load_all(conn, oid)

        return Table(table_name, columns, description)

    @staticmethod
    def load_all(conn, schema_name):
        query = (
            "SELECT pg_class.oid "
            "FROM pg_class "
            "JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace "
            "WHERE relkind = 'r' AND pg_namespace.nspname = %s "
            "ORDER BY pg_class.relname"
        )

        args = (schema_name,)

        with closing(conn.cursor()) as cursor:
            cursor.execute(query, args)

            return [Table.load(conn, oid) for oid, in cursor.fetchall()]

    def to_rst(self):
        column_names = ["Name", "Type", "Description"]

        return [
            self.name,
            len(self.name) * '`',
            '',
            format_value(self.description),
            ''
        ] + list(to_lines(tabulate(
            [(column.name, column.type, column.description) for column in self.columns],
            headers=column_names,
            tablefmt="grid"
        ))) + ['']


class Function(object):
    def __init__(self, name, arguments, return_type, description):
        self.name = name
        self.arguments = arguments
        self.return_type = return_type
        self.description = description

    @staticmethod
    def load_all(conn, schema_name):
        query = (
            'SELECT proname, pg_get_function_arguments(p.oid), pg_get_function_result(p.oid), d.description '
            'FROM pg_proc p '
            'JOIN pg_namespace n ON n.oid = p.pronamespace '
            'LEFT JOIN pg_description d ON d.objoid = p.oid '
            'WHERE n.nspname = %s '
            'ORDER BY proname'
        )

        args = (schema_name,)

        with closing(conn.cursor()) as cursor:
            cursor.execute(query, args)

            return [
                Function(name, arguments, return_type, description)
                for name, arguments, return_type, description in cursor.fetchall()
            ]


SECTION_UNDERLINING = ['=', '-', '`']


def section_header(name, level):
    return [
        name,
        len(name) * SECTION_UNDERLINING[level]
    ]


def doc_tables(conn, schema_name):
    return section_header('Tables', 1) + list(chain(
        ljoin(
            '',
            (table.to_rst() for table in Table.load_all(conn, schema_name))
        )
    ))


def doc_functions(conn, schema_name):
    column_names = ["Name", "Return Type", "Description"]

    return section_header('Functions', 1) + [''] + list(to_lines(tabulate(
        [
            ('{}({})'.format(function.name, function.arguments), function.return_type, function.description)
            for function in Function.load_all(conn, schema_name)
        ],
        headers=column_names,
        tablefmt="grid"
    )))


all_doc_types = [doc_tables, doc_functions]


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('schemas', nargs='*')
    parser.add_argument('--tables', dest='doc_types', action='append_const', const=doc_tables)
    parser.add_argument('--functions', dest='doc_types', action='append_const', const=doc_functions)

    args = parser.parse_args()

    with closing(psycopg2.connect('')) as conn:
        schema_names = args.schemas or Schema.all_names(conn)

        for schema_name in schema_names:
            description = Schema.load_description(conn, schema_name)

            print(unlines(
                section_header(schema_name, 0) + [
                    '',
                    format_value(description),
                    ''
                ]
            ))

            doc_types = args.doc_types or all_doc_types

            for doc_type in doc_types:
                print(unlines(doc_type(conn, schema_name)))


if __name__ == '__main__':
    main()
